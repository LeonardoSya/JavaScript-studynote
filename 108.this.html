<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    如果在一个对象上使用点或者方括号来访问属性或方法，这个对象就成了 this。
    如果并没有使用“点”运算符调用某个对象，那么 this 将指向全局对象(global object)。这是一个经常出错的地方
    
    在绝大多数情况下 函数的调用方式决定了this的值(运行时绑定) this不能在执行期间被赋值 并且每次函数被调用时this的值也可能不同 一般情况下this的最终指向是那个调用它的对象
    箭头函数不提供自身的this绑定(this的值将保持为闭合词法上下文的值)

    在全局执行环境中(任何函数体外部) this都指向全局对象
    在函数内部 this的值取决于函数被调用的方式

    this在类中的表现与在函数中类似 因为类本质上也是函数 在类的构造函数中 this是一个常规对象 类中所有非静态的方法都会被添加到this的原型中


</head>

<body>
    <script>
        // 在浏览器中, window对象同时也是全局对象
        console.log(this === window);  // true
        this.a = 'MDN';
        console.log(window.a);  // MDN

        setTimeout(() => {
            console.log(this === window);  // true
        }, 1000);

        // 方法调用中 谁调用this指向谁
        let obj = new Object();
        obj.sayHi = function () {
            console.log(this === obj);  // true
        }
        obj.sayHi();

    </script>
</body>

</html>